#' Row and column notation
#'
#' @description
#' It is often convenient to represent row and column names
#' with notation that includes a prefix and a suffix,
#' with corresponding separators or start-end string sequences.
#' There are several functions that call `notation_vec()` to generate specialized versions
#' or otherwise manipulate row and column names on their own or as row or column names.
#'
#' * `notation_vec()` Builds a vector of notation symbols in a standard format
#'                    that is used by `matsbyname` in several places.
#'                    By default, it builds a list of notation symbols that provides an arrow
#'                    separator (" -> ") between prefix and suffix.
#' * `arrow_notation` Builds a list of notation symbols that provides an arrow separator (" -> ")
#'                      between prefix and suffix.
#' * `paren_notation` Builds a list of notation symbols that provides parentheses around the suffix ("prefix (suffix)").
#' * `bracket_notation` Builds a list of notation symbols that provides square brackets around the suffix ("prefix \[suffix\]").
#' * `preposition_notation()` Builds a list of notation symbols that provides (by default) square brackets around the suffix with a preposition ("prefix \[preposition suffix\]").
#' * `from_notation` Builds a list of notation symbols that provides (by default) square brackets around a "from" suffix ("prefix \[from suffix\]").
#' * `of_notation` Builds a list of notation symbols that provides (by default) square brackets around an "of" suffix ("prefix \[of suffix\]").
#' * `split_pref_suff()` Splits prefixes from suffixes, returning each in a list with names `pref` and `suff`.
#'                       If no prefix or suffix delimiters are found, `x` is returned in the `pref` item, unmodified,
#'                       and the `suff` item is returned as `""` (an empty string).
#'                       If there is no prefix, and empty string is returned for the `pref` item.
#'                       If there is no suffix, and empty string is returned for the `suff` item.
#' * `paste_pref_suff()` `paste0`'s prefixes and suffixes, the inverse of `split_pref_suff()`.
#' * `flip_pref_suff()` Switches the location of prefix and suffix, such that the prefix becomes the suffix, and
#'                      the suffix becomes the prefix.
#'                      E.g., "a -> b" becomes "b -> a" or "a \[b\]" becomes "b \[a\]".
#' * `keep_pref_suff()` Selects only prefix or suffix, discarding notational elements
#'                      and the rejected part.
#' * `switch_notation()` Switches from one type of notation to another based on the `from` and `to` arguments.
#'                       Optionally, prefix and suffix can be `flip`ped.
#'
#' If `sep` only is specified (default is " -> "),
#' `pref_start`, `pref_end`, `suff_start`, and `suff_end` are
#' set appropriately.
#'
#' None of the strings in a notation vector are considered part of the prefix or suffix.
#' E.g., "a -> b" in arrow notation means that "a" is the prefix and "b" is the suffix.
#'
#' @param sep A string separator between prefix and suffix. Default is " -> ".
#' @param pref_start A string indicating the start of a prefix. Default is `NULL`.
#' @param pref_end A string indicating the end of a prefix. Default is the value of `sep`.
#' @param preposition A string that specifies a preposition for a notation.
#' @param suff_start A string indicating the start of a suffix. Default is the value of `sep`.
#' @param suff_end A string indicating the end of a suffix. Default is `NULL`.
#' @param x A string or list of strings to be operated upon.
#' @param pref A string or list of strings that are prefixes. Default is `NULL`.
#' @param suff A string of list of strings that are suffixes. Default is `NULL`.
#' @param keep Tells which
#' @param ps A list of prefixes and suffixes in which each item of the list is itself a list with two items named `pref` and `suff`.
#' @param notation A notation vector generated by one of the `*_notation()` functions, such as
#'                 `notation_vec()`, `arrow_notation`, or `bracket_notation`.
#'                 Default is `arrow_notation`.
#' @param from The `notation` to switch _away from_.
#' @param to The `notation` to switch _to_.
#' @param flip A boolean that tells whether to also flip the notation. Default is `FALSE`.
#' @param preposition A string used to indicate position for energy flows, typically "from" or "to" in different notations.
#'
#' @return For `notation_vec()`, `arrow_notation`, and `bracket_notation`,
#'           a string vector with named items `pref_start`, `pref_end`, `suff_start`, and `suff_end`;
#'         For `split_pref_suff()`, a string list with named items `pref` and `suff`.
#'         For `paste_pref_suff()`, `split_pref_suff()`, and `switch_notation()`,
#'           a string list in notation format specified by various `notation` arguments, including
#'           `from`, and `to`.
#'         For `keep_pref_suff`, one of the prefix or suffix or a list of prefixes or suffixes.
#'
#' @examples
#' notation_vec()
#' arrow_notation
#' bracket_notation
#' split_pref_suff("a -> b", notation = arrow_notation)
#' flip_pref_suff("a [b]", notation = bracket_notation)
#' keep_pref_suff("a -> b", keep = "suff", notation = arrow_notation)
#' switch_notation("a -> b", from = arrow_notation, to = bracket_notation)
#' switch_notation("a -> b", from = arrow_notation, to = bracket_notation,
#'                 flip = TRUE)
#' # Also works for vectors
#' switch_notation(c("a -> b", "c -> d"), from = arrow_notation, to = bracket_notation)
#' @name row-col-notation
NULL


#' @export
#' @rdname row-col-notation
notation_vec <- function(sep = " -> ",
                         pref_start = "", pref_end = "",
                         suff_start = "", suff_end = "") {
  if (all(nchar(c(pref_start, pref_end, suff_start, suff_end)) == 0) & nchar(sep) != 0) {
    return(c(pref_start = "", pref_end = sep,
             suff_start = sep, suff_end = ""))
  }
  c(pref_start = pref_start,
    pref_end = pref_end,
    suff_start = suff_start,
    suff_end = suff_end)
}


#' @export
#' @rdname row-col-notation
preposition_notation <- function(preposition, suff_start = " [", suff_end = "]") {
  notation_vec(sep = "",
               pref_start = "",
               pref_end = paste0(suff_start, preposition, " "),
               suff_start = paste0(suff_start, preposition, " "),
               suff_end = suff_end)
}


#' @export
#' @rdname row-col-notation
split_pref_suff <- function(x, notation = RCLabels::arrow_notation) {

  # Vectorize so the gsub function works correctly.
  out <- list()
  for (i in 1:length(x)) {
    # Strip off first pref_start
    this_x <- x[[i]]
    no_pref_start <- gsub(pattern = paste0("^", Hmisc::escapeRegex(notation[["pref_start"]])), replacement = "", x = this_x)
    # Strip off everything from first pref_end to end of string to obtain the prefix
    pref <- gsub(pattern = paste0(Hmisc::escapeRegex(notation[["pref_end"]]), ".*$"), replacement = "", x = no_pref_start)
    # Strip off last suff_end
    no_suff_end <- gsub(pattern = paste0(Hmisc::escapeRegex(notation[["suff_end"]]), "$"), replacement = "", x = this_x)
    # Strip off everything from start of the string to first suff_start
    ss <- notation[["suff_start"]]
    if (!is.na(notation[["pref_start"]]) & !is.na(notation[["suff_start"]])) {
      if (notation[["pref_start"]] == notation[["suff_start"]]) {
        ss <- paste0(notation[["pref_end"]], notation[["suff_start"]])
      }
    }
    # Split at the first instance of suff_start to get two pieces
    suff <- stringi::stri_split_fixed(str = no_suff_end, pattern = ss, n = 2)
    suff <- lapply(suff, function(s) {
      if (length(s) == 2) {
        # If we got two pieces, choose the second piece.
        s <- s[[2]]
      } else {
        # We got only 1 piece. Return an empty string ("") to indicate a missing suffix
        s <- ""
      }
      return(s)
    }) |>
      unlist()

    if (length(x) == 1) {
      out <- append(out, list(pref = pref, suff = suff))
    } else {
      # length(x) > 1
      if (length(this_x) == 1) {
        res <- list(c(pref = pref, suff = suff))
      } else {
        # length(this_x) > 1
        res <- list(pref = pref, suff = suff) |>
          purrr::transpose() |>
          list()
      }
      out <- append(out, res)
    }
  }
  # Check the original structure.
  # Return the same structure.
  if (length(x) == 1) {
    # Knock one level of list away.
    return(unlist(out, recursive = FALSE))
  }
  return(out)
}


#' @export
#' @rdname row-col-notation
paste_pref_suff <- function(ps = list(pref = pref, suff = suff), pref = NULL, suff = NULL, notation = RCLabels::arrow_notation) {
  join_func <- function(ps) {
    out <- paste0(notation[["pref_start"]], ps[["pref"]], notation[["pref_end"]])
    if (notation[["pref_end"]] != notation[["suff_start"]]) {
      out <- paste0(out, notation[["suff_start"]])
    }
    paste0(out, ps[["suff"]], notation[["suff_end"]])
  }
  if (!is.null(names(ps))){
    if (length(ps) == 2 & all(names(ps) == c("pref", "suff"))) {
      # We have a single list of the form list(pref = xxxx, suff = yyyy)
      return(join_func(ps))
    }
  }
  lapply(ps, FUN = join_func)
}


#' @export
#' @rdname row-col-notation
flip_pref_suff <- function(x, notation = RCLabels::arrow_notation) {
  # Split prefixes and suffixes
  pref_suff <- split_pref_suff(x, notation = notation)

  flip_ps_func <- function(ps) {
    # pf is a list with only 2 items, pref and suff.
    out <- paste0(notation[["pref_start"]], ps$suff, notation[["pref_end"]])
    if (notation[["pref_end"]] != notation[["suff_start"]]) {
      out <- paste0(out, notation[["suff_start"]])
    }
    paste0(out, ps$pref, notation[["suff_end"]])
  }

  if (length(x) > 1) {
    # pref_suff is a list. So lapply to build a flipped list
    return(lapply(pref_suff, FUN = flip_ps_func))
  }
  flip_ps_func(pref_suff)
}


#' @export
#' @rdname row-col-notation
keep_pref_suff <- function(x, keep = c("pref", "suff"), notation) {
  keep <- match.arg(keep)

  choose_pref_or_suff <- function(ps, which_to_keep) {
    # ps should be an item with "pref" and "suff" named elements.
    if (which_to_keep == "pref" | ps[["suff"]] == "") {
      return(ps[["pref"]])
    }
    return(ps[["suff"]])
  }

  pref_suff <- split_pref_suff(x, notation)
  if (length(x) > 1) {
    out <- lapply(pref_suff, choose_pref_or_suff, keep) |>
      unlist()
  } else {
    out <- choose_pref_or_suff(pref_suff, keep)
  }
  return(out)
}


#' @export
#' @rdname row-col-notation
switch_notation <- function(x, from, to, flip = FALSE) {
  switch_func <- function(x) {
    ps <- split_pref_suff(x, notation = from)
    if (ps$suff == "") {
      # No split occurred, meaning the notation for prefix and suffix wasn't found.
      # In this case, return the string unmodified.
      return(x)
    }
    if (flip) {
      ps <- list(pref = ps$suff, suff = ps$pref)
    }
    paste_pref_suff(ps, notation = to)
  }

  if (length(x) > 1) {
    return(lapply(x, FUN = switch_func))
  }
  switch_func(x)
}

